function [ snapshot ] = my_condition( delx,delt,velocity,snap1,snap2,snapshot,boundary )
%UNTITLED4 Summary of this function goes here
%   Detailed explanation goes here

[nz,nx]=size(snap1);

if boundary == 1

  % apply absorbing boundary for top 

  snapshot(1,3:nx-2) = (2.*velocity(1,3:nx-2).*delx*delt.^2)./(delx+velocity(1,3:nx-2).*delt).*...
        ((snapshot(2,3:nx-2)./(2*delt*delx) - snap1(2,3:nx-2)./(2*delx*delt) + ....
         snap1(1,3:nx-2)./(2*delt*delx)) + ...
    (-1./(2.*delt.^2.*velocity(1,3:nx-2))).*...
         (-2.*snap2(1,3:nx-2) + snap1(1,3:nx-2 ) -2.*snap2(2,3:nx-2)+ ...
         snap1(2,3:nx-2) + snapshot(2,3:nx-2)) + ...
    velocity(1,3:nx-2)./(4*delx.^2).*...
         (snapshot(2,4:nx-1) + snap1(1,4:nx-1) + snapshot(2,2:nx-3) - ...
          2.* snapshot(2,3:nx-2) - 2.*snap1(1,3:nx-2) + snap1(1,2:nx-3)));


end

% apply absorbing boundary for bottom

snapshot(nz,3:nx-2) = -2.*delx.*delt.^2.*velocity(nz,3:nx-2)./(delx+velocity(nz,3:nx-2).*delt).*...
       ((-snapshot(nz-1,3:nx-2)./(2*delt*delx) - snap1(nz,3:nx-2)./(2*delt*delx) +...
       snap1(nz-1,3:nx-2)./(2*delt*delx)) +...
  1./(2*delt.^2.*velocity(nz,3:nx-2)).*...
       (-2.*snap2(nz,3:nx-2) + snap1(nz,3:nx-2) + snapshot(nz-1,3:nx-2) - ...
       2.*snap2(nz-1,3:nx-2) + snap1(nz-1,3:nx-2)) + ...
  (-velocity(nz,3:nx-2)./(4*delx.^2)).* ...
       (snapshot(nz-1,4:nx-1) - 2.*snapshot(nz-1,3:nx-2) + snapshot(nz-1,2:nx-3) + ...
       snap1(nz,4:nx-1) - 2.*snap1(nz,3:nx-2) + snap1(nz,2:nx-3)));

% apply absorbing boundary for right hand side

snapshot(3:nz-2,nx) =  -2.*delx.*delt.^2.*velocity(3:nz-2,nx)./(delx+velocity(3:nz-2,nx).*delt).*...
       ((-snapshot(3:nz-2,nx-1)./(2*delt*delx) - snap1(3:nz-2,nx)./(2*delt*delx) + ...
       snap1(3:nz-2,nx-1)./(2*delt*delx)) + ...
  1./(2*delt.^2.*velocity(3:nz-2,nx)).*...
       (-2.*snap2(3:nz-2,nx) + snap1(3:nz-2,nx) + snapshot(3:nz-2,nx-1) - ...
       2.*snap2(3:nz-2,nx-1) + snap1(3:nz-2,nx-1)) + ...
  (-velocity(3:nz-2,nx)./(4*delx.^2)).* ...
       (snapshot(4:nz-1,nx-1) - 2.*snapshot(3:nz-2,nx-1) + snapshot(2:nz-3,nx-1) + ...
       snap1(4:nz-1,nx) - 2.*snap1(3:nz-2,nx) + snap1(2:nz-3,nx)));


% apply absorbing boundary for left hand side

snapshot(3:nz-2,1) =(2.*velocity(3:nz-2,1).*delx*delt.^2)./(delx+velocity(3:nz-2,1).*delt).*...
       ((snapshot(3:nz-2,2)./(2*delt*delx) - snap1(3:nz-2,2)./(2*delt*delx) + ...
       snap1(3:nz-2,1)./(2*delt*delx)) + ...
  (-1./(2*delt.^2.*velocity(3:nz-2,1))).* ...
       (-2.*snap2(3:nz-2,1) + snap1(3:nz-2,1) + snapshot(3:nz-2,2) - ...
       2.*snap2(3:nz-2,2) + snap1(3:nz-2,2)) + ...
  (velocity(3:nz-2,1)./(4*delx.^2)).* ...
       (snapshot(4:nz-1,2) - 2.*snapshot(3:nz-2,2) + snapshot(2:nz-3,2) +...
       snap1(4:nz-1,1) - 2.*snap1(3:nz-2,1) + snap1(2:nz-3,1)));


%%%%%% Absorbing boundary conditions for corners

% for lower right hand corner

snapshot(nz-1,nx) = velocity(nz-1,nx).*delt.*delx./(2.*velocity(nz-1,nx).*delt + (2^1/2)*delx).*...
       (snapshot(nz-2,nx)./delx + snapshot(nz-1,nx-1)./delx + ...
       (2^1/2)/(velocity(nz-1,nx).*delt)*snap2(nz-1,nx));

snapshot(nz,nx-1) = velocity(nz,nx-1).*delt.*delx./(2.*velocity(nz,nx-1).*delt + (2^1/2)*delx).*...
       (snapshot(nz-1,nx-1)./delx + snapshot(nz,nx-2)./delx + ...
       (2^1/2)/(velocity(nz,nx-1).*delt)*snap2(nz,nx-1));

snapshot(nz,nx) = velocity(nz,nx).*delt.*delx./(2.*velocity(nz,nx).*delt + (2^1/2)*delx).*...
       (snapshot(nz-1,nx)./delx + snapshot(nz,nx-1)./delx + ...
       (2^1/2)/(velocity(nz,nx).*delt)*snap2(nz,nx));

% for lower left hand corner

snapshot(nz-1,1) = velocity(nz-1,1).*delt.*delx./(2.*velocity(nz-1,1).*delt + (2^1/2)*delx).*...
       (snapshot(nz-2,1)/delx + snapshot(nz-1,2)/delx +...
       (2^1/2)/(velocity(nz-1,1)*delt)*snap2(nz-1,1));

snapshot(nz,2) = velocity(nz,2).*delt.*delx./(2.*velocity(nz,2).*delt + (2^1/2)*delx).*...
       (snapshot(nz-1,2)/delx + snapshot(nz,3)/delx +...
       (2^1/2)/(velocity(nz,2)*delt)*snap2(nz,2));

snapshot(nz,1) = velocity(nz,1).*delt.*delx./(2.*velocity(nz,1).*delt + (2^1/2)*delx).*...
       (snapshot(nz-1,1)/delx + snapshot(nz,2)/delx +...
       (2^1/2)/(velocity(nz,1)*delt)*snap2(nz,1));

if boundary == 1

  % for upper right hand corner

  snapshot(2,nx) = velocity(2,nx).*delt.*delx./(2.*velocity(2,nx).*delt + (2^1/2)*delx).*...
         (snapshot(3,nx)/delx + snapshot(2,nx-1)/delx +...
         (2^1/2)/(velocity(2,nx)*delt)*snap2(2,nx));

  snapshot(1,nx-1) = velocity(1,nx-1).*delt.*delx./(2.*velocity(1,nx-1).*delt + (2^1/2)*delx).*...
         (snapshot(2,nx-1)/delx + snapshot(1,nx-2)/delx +...
         (2^1/2)/(velocity(1,nx-1)*delt)*snap2(1,nx-1));

  snapshot(1,nx) = velocity(1,nx).*delt.*delx./(2.*velocity(1,nx).*delt + (2^1/2)*delx).*...
         (snapshot(2,nx)/delx + snapshot(1,nx-1)/delx +...
         (2^1/2)/(velocity(1,nx)*delt)*snap2(1,nx));

  % for upper left hand corner

  snapshot(2,1) = velocity(2,1).*delt.*delx./(2.*velocity(2,1).*delt + (2^1/2)*delx).*...
         (snapshot(3,1)/delx + snapshot(2,2)/delx + ...
         (2^1/2)/(velocity(2,1)*delt)*snap2(2,1));
 
  snapshot(1,2) = velocity(1,2).*delt.*delx./(2.*velocity(1,2).*delt + (2^1/2)*delx).*...
         (snapshot(2,2)/delx + snapshot(1,3)/delx + ...
         (2^1/2)/(velocity(1,2)*delt)*snap2(1,2));

  snapshot(1,1) = velocity(1,1).*delt.*delx./(2.*velocity(1,1).*delt + (2^1/2)*delx).*...
         (snapshot(2,1)/delx + snapshot(1,2)/delx + ...
         (2^1/2)/(velocity(1,1)*delt)*snap2(1,1));

end
end

